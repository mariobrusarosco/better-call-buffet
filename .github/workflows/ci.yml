name: 🚀 Enterprise CI/CD Pipeline

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]

env:
  PYTHON_VERSION: "3.11"
  POETRY_VERSION: "1.8.3"
  REGISTRY: ${{ secrets.ECR_REGISTRY }}
  IMAGE_NAME: better-call-buffet

jobs:
  # 🔍 Static Analysis & Security (Fast Feedback)
  static-analysis:
    name: 🔍 Static Analysis & Security
    runs-on: ubuntu-latest
    steps:
      - name: 📥 Checkout Code
        uses: actions/checkout@v4

      - name: 🐍 Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: 📦 Install Poetry
        uses: snok/install-poetry@v1
        with:
          version: ${{ env.POETRY_VERSION }}
          virtualenvs-create: true
          virtualenvs-in-project: true

      - name: 🔄 Load cached dependencies
        uses: actions/cache@v3
        with:
          path: .venv
          key: venv-${{ runner.os }}-${{ env.PYTHON_VERSION }}-${{ hashFiles('**/poetry.lock') }}

      - name: 📚 Install dependencies
        run: poetry install --with dev

      - name: 🎨 Code Formatting (Black)
        run: poetry run black --check .

      - name: 📋 Import Sorting (isort)
        run: poetry run isort --check-only .

      - name: 🛡️ Security Audit (Safety)
        run: |
          poetry add --group dev safety
          poetry run safety check --ignore=70716 --ignore=70715 --ignore=64459 --ignore=64396

      - name: 📊 Dependency Check (pip-audit)
        run: |
          poetry add --group dev pip-audit
          poetry run pip-audit

  # 🧪 Unit Tests (Fast, No External Dependencies)
  unit-tests:
    name: 🧪 Unit Tests
    runs-on: ubuntu-latest
    needs: static-analysis
    steps:
      - name: 📥 Checkout Code
        uses: actions/checkout@v4

      - name: 🐍 Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: 📦 Install Poetry
        uses: snok/install-poetry@v1
        with:
          version: ${{ env.POETRY_VERSION }}
          virtualenvs-create: true
          virtualenvs-in-project: true

      - name: 🔄 Load cached dependencies
        uses: actions/cache@v3
        with:
          path: .venv
          key: venv-${{ runner.os }}-${{ env.PYTHON_VERSION }}-${{ hashFiles('**/poetry.lock') }}

      - name: 📚 Install dependencies
        run: poetry install --with dev

      - name: 🧪 Run Unit Tests
        run: |
          poetry run pytest tests/ -v --tb=short
        env:
          DATABASE_URL: sqlite:///./test.db

  # 🐳 Build & Test Docker Image
  build-and-test:
    name: 🐳 Build & Test Container
    runs-on: ubuntu-latest
    needs: [static-analysis, unit-tests]
    services:
      postgres:
        image: postgres:15-alpine
        env:
          POSTGRES_DB: test_db
          POSTGRES_USER: test_user
          POSTGRES_PASSWORD: test_pass
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

    steps:
      - name: 📥 Checkout Code
        uses: actions/checkout@v4

      - name: 🔧 Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: 🏗️ Build Docker Image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: false
          load: true
          tags: ${{ env.IMAGE_NAME }}:test
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: 🔍 Security Scan Docker Image
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ env.IMAGE_NAME }}:test
          format: "sarif"
          output: "trivy-results.sarif"
        continue-on-error: true

      - name: 🧪 Test Container (No Database)
        run: |
          echo "🚀 Testing container startup without database dependency..."
          CONTAINER_ID=$(docker run -d --name test-app -p 8000:8000 \
            -e DATABASE_URL="sqlite:///./test.db" \
            ${{ env.IMAGE_NAME }}:test)

          echo "⏳ Waiting for application to start..."
          sleep 10

          # Test health endpoint
          for i in {1..6}; do
            if curl -f --silent --max-time 5 http://localhost:8000/health; then
              echo "✅ Health check passed!"
              break
            else
              echo "⏳ Attempt $i failed, waiting 5s..."
              sleep 5
            fi
            
            if [ $i -eq 6 ]; then
              echo "❌ Health check failed"
              echo "🔍 Container logs:"
              docker logs test-app
              exit 1
            fi
          done

          echo "🛑 Stopping container..."
          docker stop test-app
          docker rm test-app

      - name: 🗄️ Test Container with Database
        run: |
          echo "🚀 Testing container with PostgreSQL..."
          CONTAINER_ID=$(docker run -d --name test-app-db -p 8001:8000 \
            -e DATABASE_URL="postgresql://test_user:test_pass@localhost:5432/test_db" \
            -e RUN_MIGRATIONS="true" \
            --network host \
            ${{ env.IMAGE_NAME }}:test)

          echo "⏳ Waiting for migrations and app startup..."
          sleep 15

          # Test health endpoint
          for i in {1..6}; do
            if curl -f --silent --max-time 5 http://localhost:8001/health; then
              echo "✅ Database integration test passed!"
              break
            else
              echo "⏳ Attempt $i failed, waiting 5s..."
              sleep 5
            fi
            
            if [ $i -eq 6 ]; then
              echo "❌ Database integration test failed"
              echo "🔍 Container logs:"
              docker logs test-app-db
              exit 1
            fi
          done

          echo "🛑 Stopping container..."
          docker stop test-app-db
          docker rm test-app-db

      - name: 📊 Container Image Analysis
        run: |
          echo "📋 Image size and layers:"
          docker images ${{ env.IMAGE_NAME }}:test
          docker history ${{ env.IMAGE_NAME }}:test

  # 🚀 Push to Registry (Only on main/develop)
  push-to-registry:
    name: 🚀 Push to ECR
    runs-on: ubuntu-latest
    needs: build-and-test
    if: github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/develop')
    outputs:
      image-tag: ${{ steps.meta.outputs.tags }}
      image-digest: ${{ steps.build.outputs.digest }}

    steps:
      - name: 📥 Checkout Code
        uses: actions/checkout@v4

      - name: 🔐 Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: 🔧 Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: 🐳 Login to Amazon ECR
        run: |
          aws ecr get-login-password --region ${{ secrets.AWS_REGION }} | \
          docker login --username AWS --password-stdin ${{ env.REGISTRY }}

      - name: 🏷️ Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}

      - name: 🏗️ Build and Push
        id: build
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: 📝 Generate Build Summary
        run: |
          echo "## 🚀 Build Complete!" >> $GITHUB_STEP_SUMMARY
          echo "**Image:** ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}" >> $GITHUB_STEP_SUMMARY
          echo "**Tags:** ${{ steps.meta.outputs.tags }}" >> $GITHUB_STEP_SUMMARY
          echo "**Digest:** ${{ steps.build.outputs.digest }}" >> $GITHUB_STEP_SUMMARY

  # 🎯 Deploy to Production (main branch only)
  deploy-production:
    name: 🎯 Deploy to Production
    runs-on: ubuntu-latest
    needs: push-to-registry
    if: github.ref == 'refs/heads/main'
    environment: production

    steps:
      - name: 📥 Checkout Code
        uses: actions/checkout@v4

      - name: 🔐 Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: 🗄️ Run Database Migrations
        run: |
          echo "🔄 Running database migrations..."
          # For now, we'll run migrations in App Runner until ECS task is set up
          echo "⚠️  Migration will run in App Runner container for now"
          echo "🔄 TODO: Set up dedicated ECS migration task"

      - name: 🚀 Deploy to App Runner
        run: |
          echo "🚀 Deploying to App Runner..."

          # Try to update service first, if it fails, create new service
          aws apprunner update-service \
            --service-arn ${{ secrets.APP_RUNNER_SERVICE_ARN }} \
            --source-configuration '{
              "ImageRepository": {
                "ImageIdentifier": "${{ needs.push-to-registry.outputs.image-tag }}",
                "ImageConfiguration": {
                  "Port": "8000",
                  "RuntimeEnvironmentVariables": {
                    "DATABASE_URL": "${{ secrets.PROD_DATABASE_URL }}",
                    "SECRET_KEY": "${{ secrets.PROD_SECRET_KEY }}",
                    "ENVIRONMENT": "production",
                    "RUN_MIGRATIONS": "true"
                  }
                }
              }
            }' || \
          aws apprunner create-service \
            --service-name better-call-buffet-prod \
            --source-configuration '{
              "ImageRepository": {
                "ImageIdentifier": "${{ needs.push-to-registry.outputs.image-tag }}",
                "ImageConfiguration": {
                  "Port": "8000",
                  "RuntimeEnvironmentVariables": {
                    "DATABASE_URL": "${{ secrets.PROD_DATABASE_URL }}",
                    "SECRET_KEY": "${{ secrets.PROD_SECRET_KEY }}",
                    "ENVIRONMENT": "production",
                    "RUN_MIGRATIONS": "true"
                  }
                },
                "ImageRepositoryType": "ECR"
              },
              "AutoDeploymentsEnabled": false
            }' \
            --instance-configuration '{
              "Cpu": "1024",
              "Memory": "2048"
            }'

      - name: 🏥 Health Check Production
        run: |
          echo "⏳ Waiting for deployment..."
          sleep 60

          HEALTH_URL="${{ secrets.PROD_APP_URL }}/health"
          for i in {1..10}; do
            if curl -f --silent --max-time 10 $HEALTH_URL; then
              echo "✅ Production deployment successful!"
              exit 0
            else
              echo "⏳ Health check $i/10 failed, waiting 30s..."
              sleep 30
            fi
          done

          echo "❌ Production health check failed!"
          exit 1

  # 📊 Post-Deployment Monitoring
  post-deploy-monitoring:
    name: 📊 Post-Deploy Monitoring
    runs-on: ubuntu-latest
    needs: deploy-production
    if: always() && github.ref == 'refs/heads/main'

    steps:
      - name: 📈 Trigger Monitoring Checks
        run: |
          echo "📊 Deployment monitoring initiated"
          echo "- Health checks: ✅"
          echo "- Performance metrics: Collecting..."
          echo "- Error rates: Monitoring..."
          # Here you'd typically trigger DataDog, New Relic, etc.
