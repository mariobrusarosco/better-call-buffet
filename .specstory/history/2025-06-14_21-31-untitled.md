<!-- Generated by SpecStory -->

# Untitled (2025-06-14 18:31:32)

_**User**_

Perfect:

Now, we need to receive the parsed data from PDF invoice and the two things:

* Save the invoice on the DB
* Save each transaction on the DB


1. We need a new domain for Transaction
2. We need to make the credit-card router to work

Request from Front:

* POST' to '/api/v1/credit-card/' 
* Example of payload from the front end:

{
    "credit_card_id": "08cf8602-5fc6-44d2-a36a-0b4ca2195c23",
    "broker_id": "1",
    "raw_invoice": {
        "total_due": "198.95",
        "due_date": "05/03/2025",
        "period": "01/02/2025 - 01/03/2025",
        "min_payment": "29.84",
        "installment_options": [],
        "transactions": [
            {
                "date": "21/01/2025",
                "description": "Hiper Farmac (2/2)",
                "amount": "50.00",
                "category": ""
            },
            {
                "date": "02/02/2025",
                "description": "Maria Cereja Padaria",
                "amount": "204.70",
                "category": ""
            }
        ],
        "next_due_info": {
            "amount": "",
            "balance": "15086.75"
        }
    }
}

---

_**Assistant**_

I'll help you implement the credit card invoice and transaction handling. Let's break this down into steps:

1. First, let's check the existing code structure to see where we need to add our new components.

---

Could not resolve URI: Error: Unable to resolve nonexistent file 'c:\Users\mario\coding\better-call-buffet\src'

---

Let me check the root directory first to understand the project structure.

---

<details>
            <summary>Listed current directory â€¢ **31** results</summary>
        
| Name |
|-------|
| ğŸ“ `.git` |
| ğŸ“ `migrations` |
| ğŸ“ `app` |
| ğŸ“ `scripts` |
| ğŸ“„ `pyproject.toml` |
| ğŸ“„ `requirements.txt` |
| ğŸ“„ `setup.ps1` |
| ğŸ“„ `setup.sh` |
| ğŸ“ `docs` |
| ğŸ“„ `docker-compose.yml` |
| ğŸ“„ `Dockerfile` |
| ğŸ“„ `README.md` |
| ğŸ“„ `.dockerignore` |
| ğŸ“ `.ebextensions` |
| ğŸ“ `utilities` |
| ğŸ“ `__pycache__` |
| ğŸ“ `lint_env` |
| ğŸ“ `.specstory` |
| ğŸ“ `.cursor` |
| ğŸ“ `.github` |
| ğŸ“ `.pytest_cache` |
| ğŸ“ `aws` |
| ğŸ“ `logs` |
| ğŸ“ `.vscode` |
| ğŸ“ `tests` |
| ğŸ“„ `alembic.ini` |
| ğŸ“„ `.cursorignore` |
| ğŸ“„ `.cursorindexingignore` |
| ğŸ“„ `Procfile` |
| ğŸ“„ `.ebignore` |
| ğŸ“„ `.gitignore` |

</details>

---

Let's check the app directory where our main code should be:

---

<details>
            <summary>Listed directory app â€¢ **6** results</summary>
        
| Name |
|-------|
| ğŸ“ `__pycache__` |
| ğŸ“„ `main.py` |
| ğŸ“ `core` |
| ğŸ“ `db` |
| ğŸ“ `domains` |
| ğŸ“ `api` |

</details>

---

Let's first check the existing credit card domain and router to see what we need to modify:

---

<details>
            <summary>Searched codebase "credit card domain or model definition" â€¢ **17** results</summary>
        
| File | Lines |
|------|-------|
| `app/domains/accounts/models.py` | L1-12 |
| `app/domains/accounts/schemas.py` | L1-12 |
| `app/domains/accounts/schemas.py` | L64-74 |
| `app/domains/accounts/schemas.py` | L48-59 |
| `app/domains/accounts/schemas.py` | L25-34 |
| `app/domains/accounts/schemas.py` | L12-21 |
| `app/domains/accounts/models.py` | L12-30 |
| `app/domains/accounts/schemas.py` | L59-64 |
| `app/domains/accounts/schemas.py` | L21-25 |
| `app/domains/accounts/schemas.py` | L34-44 |
| `app/domains/accounts/service.py` | L1-33 |
| `app/domains/accounts/schemas.py` | L44-48 |
| `app/domains/accounts/router.py` | L36-46 |
| `app/domains/accounts/router.py` | L1-18 |
| `app/domains/accounts/router.py` | L18-28 |
| `app/domains/accounts/router.py` | L28-36 |
| `app/domains/users/__init__.py` | L1-2 |

</details>

---

Let's also check if there's any existing credit card specific code:

---

<details>
            <summary>Searched codebase "credit card router or credit card invoice" â€¢ **0** results</summary>
        
No results found
</details>

---

Based on the search results, we need to create several new components. Let's implement them step by step:

1. First, let's create the Transaction domain model:

---

```diff
- 
+ from datetime import datetime
+ from sqlalchemy import Column, DateTime, String, Float, ForeignKey, Index
+ from sqlalchemy.orm import relationship
+ from sqlalchemy.dialects.postgresql import UUID
+ import uuid
+ 
+ from app.db.connection_and_session import Base
+ 
+ class Transaction(Base):
+     __tablename__ = "transactions"
+     __table_args__ = (
+         Index('ix_transactions_credit_card_id', 'credit_card_id'),  # Index for faster credit card lookups
+         Index('ix_transactions_date', 'date'),  # Index for date filtering
+     )
+ 
+     id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4, index=True)
+     credit_card_id = Column(UUID(as_uuid=True), ForeignKey('accounts.id'), nullable=False)
+     date = Column(DateTime, nullable=False)
+     description = Column(String, nullable=False)
+     amount = Column(Float, nullable=False)
+     category = Column(String, nullable=True)
+     created_at = Column(DateTime, default=datetime.utcnow, nullable=False)
+     updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow, nullable=False)
+ 
+     # Relationship
+     credit_card = relationship("Account", back_populates="transactions") 
```

---

2. Now let's create the schemas for Transaction and CreditCardInvoice:

---

```diff
- 
+ from datetime import datetime
+ from pydantic import BaseModel, Field
+ from typing import List, Optional
+ from uuid import UUID
+ 
+ class TransactionBase(BaseModel):
+     date: datetime
+     description: str
+     amount: float
+     category: Optional[str] = None
+ 
+ class TransactionCreate(TransactionBase):
+     pass
+ 
+ class Transaction(TransactionBase):
+     id: UUID
+     credit_card_id: UUID
+     created_at: datetime
+     updated_at: datetime
+ 
+     class Config:
+         from_attributes = True
+ 
+ class NextDueInfo(BaseModel):
+     amount: Optional[str] = None
+     balance: Optional[str] = None
+ 
+ class InstallmentOption(BaseModel):
+     installments: int
+     amount: float
+ 
+ class RawInvoice(BaseModel):
+     total_due: str
+     due_date: str
+     period: str
+     min_payment: str
+     installment_options: List[InstallmentOption] = []
+     transactions: List[TransactionBase]
+     next_due_info: NextDueInfo
+ 
+ class CreditCardInvoiceCreate(BaseModel):
+     credit_card_id: UUID
+     broker_id: UUID
+     raw_invoice: RawInvoice 
```

---

3. Let's create the service to handle transactions:

---

```diff
- 
+ from datetime import datetime
+ from typing import List
+ from sqlalchemy.orm import Session
+ from uuid import UUID
+ 
+ from app.domains.transactions.models import Transaction
+ from app.domains.transactions.schemas import TransactionCreate, CreditCardInvoiceCreate
+ from app.domains.accounts.models import Account
+ 
+ class TransactionService:
+     def __init__(self, db: Session):
+         self.db = db
+ 
+     def create_transactions_from_invoice(self, invoice_data: CreditCardInvoiceCreate) -> List[Transaction]:
+         # Verify credit card exists and belongs to user
+         credit_card = self.db.query(Account).filter(
+             Account.id == invoice_data.credit_card_id,
+             Account.type == "credit"
+         ).first()
+         
+         if not credit_card:
+             raise ValueError("Credit card not found or invalid type")
+ 
+         transactions = []
+         for tx_data in invoice_data.raw_invoice.transactions:
+             # Create transaction
+             transaction = Transaction(
+                 credit_card_id=invoice_data.credit_card_id,
+                 date=datetime.strptime(tx_data.date, "%d/%m/%Y"),
+                 description=tx_data.description,
+                 amount=float(tx_data.amount),
+                 category=tx_data.category
+             )
+             self.db.add(transaction)
+             transactions.append(transaction)
+ 
+         # Update credit card balance
+         credit_card.balance = float(invoice_data.raw_invoice.total_due)
+         
+         self.db.commit()
+         return transactions
+ 
+     def get_transactions_by_credit_card(self, credit_card_id: UUID) -> List[Transaction]:
+         return self.db.query(Transaction).filter(
+             Transaction.credit_card_id == credit_card_id
+         ).order_by(Transaction.date.desc()).all() 
```

---

4. Now let's create the router for credit card operations:

---

```diff
- 
+ from fastapi import APIRouter, Depends, HTTPException
+ from sqlalchemy.orm import Session
+ from typing import List
+ from uuid import UUID
+ 
+ from app.db.connection_and_session import get_db_session
+ from app.core.dependencies import get_current_user_id
+ from app.domains.transactions.schemas import Transaction, CreditCardInvoiceCreate
+ from app.domains.transactions.service import TransactionService
+ 
+ router = APIRouter()
+ 
+ @router.post("/", response_model=List[Transaction])
+ def create_credit_card_invoice(
+     invoice_data: CreditCardInvoiceCreate,
+     db: Session = Depends(get_db_session),
+     current_user_id: UUID = Depends(get_current_user_id)
+ ):
+     try:
+         service = TransactionService(db)
+         return service.create_transactions_from_invoice(invoice_data)
+     except ValueError as e:
+         raise HTTPException(status_code=400, detail=str(e))
+ 
+ @router.get("/{credit_card_id}/transactions", response_model=List[Transaction])
+ def get_credit_card_transactions(
+     credit_card_id: UUID,
+     db: Session = Depends(get_db_session),
+     current_user_id: UUID = Depends(get_current_user_id)
+ ):
+     service = TransactionService(db)
+     return service.get_transactions_by_credit_card(credit_card_id) 
```

---

5. Let's update the Account model to include the relationship with transactions:

---

```diff
      # Relationships
      broker = relationship("Broker", foreign_keys=[broker_id])
+     transactions = relationship("Transaction", back_populates="credit_card")
  
  
```

---

6. Finally, let's register the credit card router in the main API router:

---

<details>
            <summary>Searched codebase "main router or API router registration" â€¢ **1** results</summary>
        
| File | Lines |
|------|-------|
| `app/api/v1/__init__.py` | L1-15 |

</details>

---

Let's register our credit card router:

---

```diff
  from app.domains.invoices.router import router as invoices_router
  from app.domains.brokers.router import router as brokers_router
+ from app.api.v1.credit_card import router as credit_card_router
      
  api_router = APIRouter(prefix="/api/v1")    
```

```diff
  api_router.include_router(invoices_router, prefix="/invoices", tags=["invoices"])
  api_router.include_router(brokers_router, prefix="/brokers", tags=["brokers"])
+ api_router.include_router(credit_card_router, prefix="/credit-card", tags=["credit-card"])
```

---

Now we need to create a migration for the new transaction table. Let's create a new migration file:

---



---



---

