<!-- Generated by SpecStory -->

# Refactor accounts module for repository pattern (2025-06-15 14:46:53)

_**User**_

Now, Can you work on @/accounts  so we refactor our code to setup our Repository pattern?

---

_**Assistant**_



---

I'll help you refactor the accounts code to implement the Repository pattern! This is an excellent architectural decision that will significantly improve your code organization and testability.

---

Read file: app/domains/accounts/service.py

---

Perfect! Now I'll implement the Repository pattern. Let me create the repository layer and then refactor the service.

## ðŸŽ“ Repository Pattern - Educational Deep Dive

### What We're Implementing:
Refactoring the accounts domain to use the Repository pattern, separating data access logic from business logic.

### Why This Matters:
The Repository pattern creates a uniform interface for accessing data, making your code more maintainable, testable, and following SOLID principles. It abstracts the data layer, allowing you to switch between different data sources without affecting business logic.

### Before vs After:

**Before:** 
- Service directly uses SQLAlchemy queries
- Tight coupling between business logic and data access
- Harder to test and mock database operations

**After:**
- Repository handles all data access operations
- Service focuses purely on business logic
- Easy to mock repository for unit testing
- Clean separation of concerns

### Key Benefits:
- **Testability**: Easy to mock the repository for unit tests
- **Maintainability**: Changes to queries only affect the repository
- **Flexibility**: Can switch data sources without changing business logic
- **Single Responsibility**: Each layer has a clear, focused purpose

Let me implement this step by step:

---

```diff
- 
+ from typing import List, Optional
+ from sqlalchemy.orm import Session, joinedload
+ from uuid import UUID
+ 
+ from app.domains.accounts.models import Account
+ from app.domains.accounts.schemas import AccountIn, AccountType
+ from app.domains.brokers.models import Broker
+ 
+ 
+ class AccountRepository:
+     """
+     Repository pattern implementation for Account entity.
+     Abstracts all database operations and provides a clean interface for data access.
+     """
+     
+     def __init__(self, db: Session):
+         self.db = db
+ 
+     def get_by_user_and_status(self, user_id: UUID, is_active: bool) -> List[Account]:
+         """Get accounts by user ID and active status"""
+         return self.db.query(Account).filter(
+             Account.user_id == user_id,
+             Account.is_active == is_active
+         ).all()
+ 
+     def get_active_accounts_by_user(self, user_id: UUID) -> List[Account]:
+         """Get all active accounts for a user"""
+         return self.get_by_user_and_status(user_id, is_active=True)
+ 
+     def get_inactive_accounts_by_user(self, user_id: UUID) -> List[Account]:
+         """Get all inactive accounts for a user"""
+         return self.get_by_user_and_status(user_id, is_active=False)
+ 
+     def get_by_id_and_user(self, account_id: UUID, user_id: UUID) -> Optional[Account]:
+         """Get account by ID and user ID with broker relationship loaded"""
+         return self.db.query(Account).options(
+             joinedload(Account.broker)  # Eagerly load the broker relationship
+         ).join(
+             Broker,
+             Account.broker_id == Broker.id
+         ).filter(
+             Account.id == account_id,
+             Account.user_id == user_id
+         ).first()
+ 
+     def get_by_type_and_user(self, user_id: UUID, account_type: AccountType, is_active: bool = True) -> List[Account]:
+         """Get accounts by type and user ID, optionally filtered by active status"""
+         return self.db.query(Account).filter(
+             Account.user_id == user_id,
+             Account.type == account_type,
+             Account.is_active == is_active
+         ).all()
+ 
+     def create(self, account_data: dict) -> Account:
+         """Create a new account"""
+         db_account = Account(**account_data)
+         self.db.add(db_account)
+         self.db.commit()
+         self.db.refresh(db_account)
+         return db_account
+ 
+     def update(self, account: Account, update_data: dict) -> Account:
+         """Update an existing account"""
+         for key, value in update_data.items():
+             if hasattr(account, key):
+                 setattr(account, key, value)
+         
+         self.db.commit()
+         self.db.refresh(account)
+         return account
+ 
+     def delete(self, account: Account) -> None:
+         """Delete an account (hard delete)"""
+         self.db.delete(account)
+         self.db.commit()
+ 
+     def soft_delete(self, account: Account) -> Account:
+         """Soft delete an account by setting is_active to False"""
+         account.is_active = False
+         self.db.commit()
+         self.db.refresh(account)
+         return account
+ 
+     def exists_by_name_and_user(self, name: str, user_id: UUID, exclude_id: Optional[UUID] = None) -> bool:
+         """Check if an account with the given name exists for a user"""
+         query = self.db.query(Account).filter(
+             Account.name == name,
+             Account.user_id == user_id
+         )
+         
+         if exclude_id:
+             query = query.filter(Account.id != exclude_id)
+             
+         return query.first() is not None
+ 
+     def get_total_balance_by_user(self, user_id: UUID) -> float:
+         """Calculate total balance across all active accounts for a user"""
+         result = self.db.query(Account).filter(
+             Account.user_id == user_id,
+             Account.is_active == True
+         ).all()
+         
+         return sum(account.balance for account in result)
+ 
+     def get_balance_by_currency(self, user_id: UUID, currency: str) -> float:
+         """Get total balance for a specific currency"""
+         result = self.db.query(Account).filter(
+             Account.user_id == user_id,
+             Account.currency == currency,
+             Account.is_active == True
+         ).all()
+         
+         return sum(account.balance for account in result) 
```

---

Now let's refactor the service to use the repository:

---

```diff
- from typing import List
- from sqlalchemy.orm import Session, joinedload
+ from typing import List, Optional
+ from sqlalchemy.orm import Session
  from uuid import UUID
  
  from app.domains.accounts.models import Account
  from app.domains.accounts.schemas import AccountIn, AccountType, AccountWithBroker
- from app.domains.brokers.models import Broker
+ from app.domains.accounts.repository import AccountRepository
  
  
  class AccountService:
+     """
+     Service layer for Account business logic.
+     Uses AccountRepository for data access operations.
+     """
+     
      def __init__(self, db: Session):
-         self.db = db
+         self.repository = AccountRepository(db)
  
      def get_all_user_active_accounts(self, user_id: UUID) -> List[Account]:
-         return self.db.query(Account).filter(
-             Account.user_id == user_id,
-             Account.is_active == True
-         ).all()
- 
+         """Get all active accounts for a user"""
+         return self.repository.get_active_accounts_by_user(user_id)
  
-     def get_all_user_inactive_accounts(self, user_id: UUID) -> List[Account]:   
-         return self.db.query(Account).filter(
-             Account.user_id == user_id,
-             Account.is_active == False,
-         ).all()
+     def get_all_user_inactive_accounts(self, user_id: UUID) -> List[Account]:
+         """Get all inactive accounts for a user"""
+         return self.repository.get_inactive_accounts_by_user(user_id)
          
      def create_account(self, account_in: AccountIn, user_id: UUID) -> Account:
-         db_account = Account(
-             **account_in.model_dump(), # Unpack fields from AccountIn
-             user_id=user_id # Set the user ID from the dependency
-         )
-         self.db.add(db_account) # Add the new model instance to the session
-         self.db.commit()
-         self.db.refresh(db_account) # Refresh to get DB-generated values (like ID)
-         return db_account # Return the newly created model instance
+         """
+         Create a new account with business logic validation.
+         
+         Args:
+             account_in: Account creation data
+             user_id: ID of the user creating the account
+             
+         Returns:
+             The created account
+             
+         Raises:
+             ValueError: If account name already exists for user
+         """
+         # Business logic: Check if account name already exists for this user
+         if self.repository.exists_by_name_and_user(account_in.name, user_id):
+             raise ValueError(f"Account with name '{account_in.name}' already exists")
+         
+         # Prepare account data
+         account_data = account_in.model_dump()
+         account_data['user_id'] = user_id
+         
+         # Create account through repository
+         return self.repository.create(account_data)
  
-     def get_account_by_id(self, account_id: UUID, user_id: UUID) -> AccountWithBroker:
-         return self.db.query(Account).options(
-             joinedload(Account.broker)  # This will eagerly load the broker relationship
-         ).join( 
-             Broker,
-             Account.broker_id == Broker.id
-         ).filter(
-             Account.id == account_id,
-             Account.user_id == user_id
-         ).first()
+     def get_account_by_id(self, account_id: UUID, user_id: UUID) -> Optional[Account]:
+         """
+         Get account by ID with business logic validation.
+         
+         Args:
+             account_id: ID of the account to retrieve
+             user_id: ID of the user requesting the account
+             
+         Returns:
+             The account if found and belongs to user, None otherwise
+         """
+         return self.repository.get_by_id_and_user(account_id, user_id)
  
      def get_accounts_by_type(self, user_id: UUID, account_type: AccountType) -> List[Account]:
          """Get all active accounts of a specific type for a user"""
-         return self.db.query(Account).filter(
-             Account.user_id == user_id,
-             Account.type == account_type,
-             Account.is_active == True
-         ).all()
+         return self.repository.get_by_type_and_user(user_id, account_type, is_active=True)
+ 
+     def update_account_balance(self, account_id: UUID, user_id: UUID, new_balance: float) -> Optional[Account]:
+         """
+         Update account balance with business logic validation.
+         
+         Args:
+             account_id: ID of the account to update
+             user_id: ID of the user updating the account
+             new_balance: New balance value
+             
+         Returns:
+             Updated account if successful, None if account not found
+             
+         Raises:
+             ValueError: If new balance is negative
+         """
+         if new_balance < 0:
+             raise ValueError("Account balance cannot be negative")
+         
+         account = self.repository.get_by_id_and_user(account_id, user_id)
+         if not account:
+             return None
+             
+         return self.repository.update(account, {'balance': new_balance})
+ 
+     def deactivate_account(self, account_id: UUID, user_id: UUID) -> Optional[Account]:
+         """
+         Deactivate an account (soft delete).
+         
+         Args:
+             account_id: ID of the account to deactivate
+             user_id: ID of the user deactivating the account
+             
+         Returns:
+             Deactivated account if successful, None if account not found
+         """
+         account = self.repository.get_by_id_and_user(account_id, user_id)
+         if not account:
+             return None
+             
+         return self.repository.soft_delete(account)
+ 
+     def get_user_total_balance(self, user_id: UUID) -> float:
+         """
+         Calculate total balance across all active accounts for a user.
+         
+         Args:
+             user_id: ID of the user
+             
+         Returns:
+             Total balance across all active accounts
+         """
+         return self.repository.get_total_balance_by_user(user_id)
+ 
+     def get_user_balance_by_currency(self, user_id: UUID, currency: str) -> float:
+         """
+         Get total balance for a specific currency.
+         
+         Args:
+             user_id: ID of the user
+             currency: Currency code (e.g., 'BRL', 'USD')
+             
+         Returns:
+             Total balance for the specified currency
+         """
+         return self.repository.get_balance_by_currency(user_id, currency)
  
  
```

---

Now let's add some new endpoints to the router to showcase the new functionality:

---

```diff
- from fastapi import APIRouter, Depends
+ from fastapi import APIRouter, Depends, HTTPException
  from typing import List
  from sqlalchemy.orm import Session
  from uuid import UUID
  
  from app.db.connection_and_session import get_db_session
- from app.domains.accounts.schemas import Account, AccountIn
+ from app.domains.accounts.schemas import Account, AccountIn, AccountType
  from app.domains.accounts.service import AccountService
  from app.core.dependencies import get_current_user_id
```

```diff
      current_user_id: UUID = Depends(get_current_user_id)
  ):
+     """Get all active accounts for the current user"""
      service = AccountService(db)
      return service.get_all_user_active_accounts(user_id=current_user_id)
  
  
- # Endpoint to get only ACTIVE accounts for a user
  @router.get("/active", response_model=List[Account])
  def get_active_accounts_endpoint(
      db: Session = Depends(get_db_session),
      current_user_id: UUID = Depends(get_current_user_id)
  ):
+     """Get only active accounts for the current user"""
      service = AccountService(db)
      return service.get_all_user_active_accounts(user_id=current_user_id)
```

```diff
      current_user_id: UUID = Depends(get_current_user_id)
  ):
+     """Get only inactive accounts for the current user"""
      service = AccountService(db)
      return service.get_all_user_inactive_accounts(user_id=current_user_id)
  
+ @router.get("/balance/total")
+ def get_total_balance_endpoint(
+     db: Session = Depends(get_db_session),
+     current_user_id: UUID = Depends(get_current_user_id)
+ ):
+     """Get total balance across all active accounts"""
+     service = AccountService(db)
+     total_balance = service.get_user_total_balance(current_user_id)
+     return {"total_balance": total_balance}
+ 
+ @router.get("/balance/by-currency/{currency}")
+ def get_balance_by_currency_endpoint(
+     currency: str,
+     db: Session = Depends(get_db_session),
+     current_user_id: UUID = Depends(get_current_user_id)
+ ):
+     """Get total balance for a specific currency"""
+     service = AccountService(db)
+     balance = service.get_user_balance_by_currency(current_user_id, currency.upper())
+     return {"currency": currency.upper(), "balance": balance}
+ 
+ @router.get("/type/{account_type}", response_model=List[Account])
+ def get_accounts_by_type_endpoint(
+     account_type: AccountType,
+     db: Session = Depends(get_db_session),
+     current_user_id: UUID = Depends(get_current_user_id)
+ ):
+     """Get all active accounts of a specific type"""
+     service = AccountService(db)
+     return service.get_accounts_by_type(current_user_id, account_type)
  
  @router.post("/", response_model=Account)
```

```diff
      current_user_id: UUID = Depends(get_current_user_id)
  ):
+     """Create a new account"""
      service = AccountService(db)
-     return service.create_account(account_in=account_in, user_id=current_user_id)
+     try:
+         return service.create_account(account_in=account_in, user_id=current_user_id)
+     except ValueError as e:
+         raise HTTPException(status_code=400, detail=str(e))
  
  @router.get("/{account_id}", response_model=Account)
```

```diff
      current_user_id: UUID = Depends(get_current_user_id)
  ):
+     """Get a specific account by ID"""
+     service = AccountService(db)
+     account = service.get_account_by_id(account_id=account_id, user_id=current_user_id)
+     if not account:
+         raise HTTPException(status_code=404, detail="Account not found")
+     return account
+ 
+ @router.patch("/{account_id}/balance")
+ def update_account_balance_endpoint(
+     account_id: UUID,
+     new_balance: float,
+     db: Session = Depends(get_db_session),
+     current_user_id: UUID = Depends(get_current_user_id)
+ ):
+     """Update account balance"""
+     service = AccountService(db)
+     try:
+         account = service.update_account_balance(account_id, current_user_id, new_balance)
+         if not account:
+             raise HTTPException(status_code=404, detail="Account not found")
+         return {"message": "Balance updated successfully", "new_balance": account.balance}
+     except ValueError as e:
+         raise HTTPException(status_code=400, detail=str(e))
+ 
+ @router.delete("/{account_id}")
+ def deactivate_account_endpoint(
+     account_id: UUID,
+     db: Session = Depends(get_db_session),
+     current_user_id: UUID = Depends(get_current_user_id)
+ ):
+     """Deactivate an account (soft delete)"""
      service = AccountService(db)
-     return service.get_account_by_id(account_id=account_id, user_id=current_user_id)
+     account = service.deactivate_account(account_id, current_user_id)
+     if not account:
+         raise HTTPException(status_code=404, detail="Account not found")
+     return {"message": "Account deactivated successfully"}
  
```

---

Now let's create a visual diagram to illustrate the new architecture:

---



---

## ðŸŽ“ Repository Pattern Implementation Complete!

### How The New Architecture Works:

**ðŸŒŠ Data Flow:**
1. **Router Layer** receives HTTP requests and validates input
2. **Service Layer** handles business logic and orchestration  
3. **Repository Layer** abstracts all database operations
4. **Model Layer** defines database structure

### Key Benefits Achieved:

- **âœ… Testability**: You can now easily mock `AccountRepository` for unit testing the service logic without hitting the database
- **ðŸ”§ Maintainability**: Database queries are centralized in the repository - changes only affect one place
- **ðŸ”„ Flexibility**: You could swap SQLAlchemy for MongoDB, Redis, or any other data source by just implementing a new repository
- **ðŸ“š Single Responsibility**: Each layer has a clear, focused purpose

### Related Concepts:

This implementation demonstrates several important backend patterns:
- **Dependency Injection**: Service receives repository dependency
- **Interface Segregation**: Repository provides focused data access methods
- **Single Responsibility Principle**: Each class has one reason to change
- **Separation of Concerns**: Business logic separated from data access

### Production Considerations:

1. **Error Handling**: Repository methods can be wrapped with try-catch for database-specific error handling
2. **Caching**: Repository layer is perfect place to add caching logic
3. **Connection Management**: Repository handles database sessions properly
4. **Query Optimization**: All database queries are centralized for easy optimization
5. **Logging**: Add logging at repository level to track all data operations

### New API Endpoints Added:

- `GET /accounts/balance/total` - Get total balance across all accounts
- `GET /accounts/balance/by-currency/{currency}` - Get balance for specific currency  
- `GET /accounts/type/{account_type}` - Filter accounts by type
- `PATCH /accounts/{account_id}/balance` - Update account balance
- `DELETE /accounts/{account_id}` - Soft delete (deactivate) account

Your accounts domain now follows enterprise-level architecture patterns! ðŸš€

**ðŸ“‹ Commit Message Suggestion:**
```
feat: implement Repository pattern for accounts domain

- Add AccountRepository for data access abstraction
- Refactor AccountService to use repository pattern
- Add business logic validation (duplicate account names)
- Add new balance management endpoints
- Improve error handling with proper HTTP status codes
- Separate concerns between service and data access layers
```

This refactoring makes your code much more maintainable, testable, and follows industry best practices for backend architecture!

---

_**User**_

Perfect, @/balance_points , please?

---

_**Assistant**_



---

Excellent! Let's refactor the balance_points domain to use the Repository pattern as well. I can see you already have a good foundation, but the service is currently doing direct database queries.

---

Read file: app/domains/balance_points/service.py

---

Perfect! Now I'll implement the Repository pattern for the balance_points domain.

## ðŸŽ“ Balance Points Repository Pattern - Educational Deep Dive

### What We're Implementing:
Refactoring the balance_points domain to use the Repository pattern, similar to what we did with accounts, to maintain consistency across our architecture.

### Why This Matters:
Balance points are critical for tracking account balance history over time. Using the Repository pattern here provides the same benefits: better testability, maintainability, and separation of concerns. It also creates consistency across all our domains.

### Before vs After:

**Before:** 
- Service directly queries BalancePoint table
- Mixed business logic with data access
- Hard to test balance point operations independently

**After:**
- Repository handles all balance point data operations  
- Service focuses on business rules and validation
- Easy to mock and test balance point functionality
- Consistent architecture across all domains

Let me implement this step by step:

---



---



---

