
## AI Coding Assistant Rules

## HEADERS

- Project Setup Assistance (2025-04-05 14:31:59)
- Domain Review (@investments and @accounts) (2025-04-29 11:05:11)


## TECH STACK

- Python 3.8
- FastAPI
- Uvicorn
- SQLAlchemy
- psycopg2-binary
- Pydantic
- Pydantic-Settings
- Python-Dotenv
- Passlib[bcrypt]
- Python-Jose[cryptography]
- Email-Validator
- Python-Multipart
- Alembic


## PROJECT DOCUMENTATION & CONTEXT SYSTEM

- README.md
- phase3-completion-summary.md
- phase3-planning.md
- phase4-implementation.md
- postman-import-guide.md
- postman-environment.json
- study/sqlalchemy-models-guide.md
- api-routing.md
- database-connection-guide.md
- aws-cli-commands.md
- cloudwatch-alarms.md
- database-config.md
- domain-drive.md
- elastic-beanstalk.md
- environment-variables.md
- infra-setup.md
- vpc-design.md
- api.md
- application-deployment-guide.md
- troubleshooting.md
- guides/database-access-with-dbeaver.md
- guides/deploying-and-seeding-production-db.md
- decisions/001-nat-gateway-omission.md
- decisions/002-iam-permissions-model.md
- decisions/003-rds-configuration-choices.md
- decisions/004-elastic-beanstalk-deployment.md
- study/09-virtual-environments.md
- study/04-ebextensions.md
- study/02-application-packaging.md
- study/10-linting-in-python.md
- study/01-elastic-beanstalk.md
- study/05-cicd-pipelines.md
- study/03-procfile.md
- study/08-environment-variables.md
- study/07-load-balancing-autoscaling.md
- study/00-phase3-learning-summary.md
- study/06-monitoring-observability.md
- study/alembic-migrations-guide.md
- study/fastapi-guide.md
- better-call-buffet-postman-collection.json
- user-domain-implementation.md
- phase4-planning.md
- phase3-completion-checklist.md
- 00-phase3-learning-summary.md
- phase1-implementation.md
- phase2-planning.md
- .what-is-this.md
- 2025-02-23_16-40-building-a-python-rest-api-for-finance-app.md
- 2025-04-15_12-05-brainstorming-personal-finance-api-development.md
- 2025-04-05_17-31-project-setup-assistance.md
- 2025-04-20_21-09-aws-deployment-and-github-actions-help.md
- 2025-04-20_21-11-starting-a-coding-conversation.md
- 2025-04-29_14-05-untitled.md
- 2025-04-29_11-05-financial-tracking-and-investment-review.md
- guides/database-migrations-guide.md


## CODING STANDARDS

- Use consistent naming conventions.
- Follow PEP 8 style guide.


## WORKFLOW & RELEASE RULES

- All code must be reviewed before merging.
- Automated testing must be performed before deployment.
- Use feature branches for new features.
- Use GitHub Actions for CI/CD pipelines.
- Deployments to Elastic Beanstalk should use the AWS CLI or the Elastic Beanstalk Console.
- Always rotate database credentials after exposure.
- Use Alembic for database migrations.


## DEBUGGING

- Use logging for debugging purposes.
- Utilize CloudWatch for real-time log monitoring in AWS Elastic Beanstalk.
- For local development, use `poetry run uvicorn app.main:app --reload --port 8001`.
- Ensure the `logs` directory exists and has write permissions.


## DATABASE RULES

- Database seeding must be performed before testing.
- Access the database via a UI like DBeaver using the provided credentials.
- Use a `.env` file for local database credentials.
- Use environment variables for production database credentials.
- Use Alembic for database migrations.  Run `alembic revision --autogenerate -m "Add new tables"` followed by `alembic upgrade head` to apply changes.


## DEPLOYMENT RULES

- Deployments to AWS Elastic Beanstalk must use the AWS CLI directly.
- Use `AWS_ACCESS_KEY_ID`, `AWS_SECRET_ACCESS_KEY`, and `AWS_REGION` secrets in GitHub Actions.
- Always use a unique version label for each deployment.
- Use a dedicated IAM user for Elastic Beanstalk deployments.
- Add the `AWSElasticBeanstalkFullAccess` and `AWSElasticBeanstalkRoleCWL` managed policies to the deployment IAM user.
- Use the `--process` flag in `aws elasticbeanstalk create-application-version`.
- Add a `sleep` command to allow for AWS eventual consistency.

## DOMAIN RULES (@investments and @accounts)

- Implement an `InvestmentBalancePoint` model to track historical investment balances.  This model should include `investment_id`, `date`, `balance`, and `movement` fields.
- Add API endpoints for creating and querying `InvestmentBalancePoint` data.
- Implement functionality to automatically calculate differences in balance (DIFF).
- Establish a clear relationship between `Investment` and `Account` models.  Consider the possibility that some accounts may be investment accounts.
- Implement a "Transactions" domain (or similar) to track financial movements (deposits, withdrawals, transfers, etc.).  This should include fields for date, amount, type, source account (if applicable), target account (if applicable), description, and user ID.  This is crucial for maintaining data integrity and providing a comprehensive audit trail.  A suggested model is provided below:

```python
class Transaction(Base):
    __tablename__ = "transactions"
    
    id = Column(Integer, primary_key=True, index=True)
    date = Column(DateTime, nullable=False)
    amount = Column(Float, nullable=False)
    type = Column(Enum("DEPOSIT", "WITHDRAWAL", "TRANSFER", "INTEREST", "FEE", "DIVIDEND"))
    
    # For transfers, source and target would both be populated
    source_account_id = Column(Integer, ForeignKey("accounts.id"), nullable=True)
    target_account_id = Column(Integer, ForeignKey("accounts.id"), nullable=True)
    
    description = Column(String, nullable=True)
    user_id = Column(Integer, nullable=False)
    created_at = Column(DateTime, default=datetime.utcnow)
```
- Create Pydantic schemas for all SQLAlchemy models to avoid FastAPI response model errors.  These schemas should be located in a `schemas.py` file within each domain.
- All models must have Pydantic schemas for use with FastAPI.  These schemas should be located in a `schemas.py` file within each domain.
- A new "Transactions" domain should be created to track financial movements.  This domain should include a `Transaction` model with fields for date, amount, type, source account (if applicable), target account (if applicable), description, and user ID.


## Database Migrations Guide

## Overview
This guide explains how to work with database migrations in Better Call Buffet using Alembic. Migrations allow us to version control our database schema and make changes safely across different environments.

## Prerequisites
- Python 3.8+
- Access to project's database
- Alembic installed (`pip install alembic`)
- Poetry installed and configured for the project.


## Initial Setup (If not done yet)

1. Initialize Alembic in your project using poetry:
```bash
poetry run alembic init migrations
```

2. Configure `alembic.ini`:  Ensure the `sqlalchemy.url` setting points to your database.  You can use environment variables for this configuration, as shown in the example below:

```ini
sqlalchemy.url = ${DATABASE_URL}
```

3. Update `migrations/env.py` to import your models:
```python
import sys
from pathlib import Path
sys.path.append(str(Path(__file__).resolve().parents[2]))

from app.db.base import Base
from app.domains.investments.model import Investment, InvestmentBalancePoint
from app.domains.accounts.models import Account
from app.core.config import settings

target_metadata = Base.metadata
```

## Working with Migrations

### Creating a New Migration

1. Make changes to your SQLAlchemy models
2. Generate a migration using poetry:
```bash
poetry run alembic revision --autogenerate -m "Description of your changes"
```
3. The migration will be created in `migrations/versions/`
4. Review the generated migration file to ensure it captures your intended changes

### Applying Migrations

1. Apply all pending migrations:
```bash
poetry run alembic upgrade head
```

2. Apply specific number of migrations:
```bash
poetry run alembic upgrade +1  # Apply next migration
```

3. Rollback migrations:
```bash
poetry run alembic downgrade -1  # Rollback one migration
poetry run alembic downgrade base  # Rollback all migrations
```

### Best Practices

1. **Always Review Generated Migrations**
   - Alembic's autogenerate is not perfect
   - Check for correct table names, column types, and constraints
   - Ensure foreign keys are properly configured

2. **Test Migrations**
   - Test both upgrade and downgrade operations
   - Use a test database before applying to production
   - Verify data integrity after migration

3. **Naming Conventions**
   - Use descriptive names for migration files
   - Include the purpose of the migration in the message
   - Example: "add_investment_balance_points_table"

4. **Version Control**
   - Always commit migration files to version control
   - Include both the migration script and any related model changes in the same commit

## Common Issues and Solutions

### Migration Not Detecting Changes
- Ensure your models are imported in `env.py`
- Check that your model inherits from `Base`
- Verify the model is properly defined with SQLAlchemy syntax

### Failed Migrations
1. Don't panic! Migrations are transactional
2. Check the error message
3. Rollback using `poetry run alembic downgrade -1`
4. Fix the issue and regenerate the migration

## Example: Adding a New Table

1. Create your SQLAlchemy model:
```python
class InvestmentBalancePoint(Base):
    __tablename__ = "investment_balance_points"
    id = Column(Integer, primary_key=True)
    investment_id = Column(Integer, ForeignKey("investments.id"))
    balance = Column(Float, nullable=False)
```

2. Generate migration:
```bash
poetry run alembic revision --autogenerate -m "Add investment balance points table"
```

3. Review and apply:
```bash
poetry run alembic upgrade head
```

## Need Help?
- Check Alembic documentation: https://alembic.sqlalchemy.org/
- Review existing migrations in `migrations/versions/`
- Consult with the team lead for complex schema changes